---
title: Roo CodeとObsidianによるコンテキスト管理
emoji: 🙆
type: tech
topics:
  - llm
  - obsidian
  - vscode
published: true
---
## 1. AI時代の開発で最大の課題は「コンテキストの損失」である

AIツール（ChatGPT, Claude, GitHub Copilot など）が普及したことで、  
コードを書く速度自体は劇的に速くなった。

しかし、開発全体の生産性はそこまで向上していない。  
理由は明確である。

### ❗人はプロンプトを忘れる。

### ❗AIは文脈を忘れる。

### ❗コードと仕様が“分断”される。

この「コンテキストの断絶」が、AI時代における最も大きな摩擦である。

本記事では、  
**Roo Code（AIを使ったコード文脈の保持）** と  
**Obsidian（意思決定・仕様・背景の保持）**  
を組み合わせた“コンテキスト管理”という新しい手法を紹介する。

---

## 2. Roo Codeが担うコンテキスト：

## **“コードベース”の理解と再現性**

Roo Code の強みは以下にある：

- `.roomodes` によるタスク別コンテキスト最適化
- `.roo\rules` によるプロジェクト全体ルール
- AIがプロジェクト全体を読み、局所ではなく“全体整合性”を考慮した提案を行う
- ファイル操作・差分生成など、開発作業をエージェント的に実行
- プロンプトがなくても「再現可能な開発プロセス」を維持できる

### 👉 Roo Codeが実現するもの

- 新規メンバーが入っても `.roomodes` と `.roo\rules` を読めば同じワークフローに乗れる
- “コードの背景文脈をAIが保持”する
- 個人依存ではなく“プロジェクト依存”の文脈になる

### ⚠️ Roo Codeの限界（盲点）

Roo Codeはコードの文脈には強いが、

- そもそもなぜその設計になったのか
- 業務要件・制約・背景
- 組織の判断理由（ADR）

といった **意味的コンテキスト** は保持しきれない。

これを放置すると、  
AIがコードを書いても“理由の欠落したプロダクト”になる。

そこで Obsidian が必要になる。

---

## 3. Obsidianが担うコンテキスト：

## **プロジェクトの「意味」「判断理由」「背景」**

Obsidianはコードエディタではない。  
しかし、**意思決定の文脈を保持するための最強のツール**である。

### Obsidianの役割

- 業務背景・要件・制約の整理
- 判断理由（Decision Log[^1] / ADR[^2]）の蓄積
- アイデア・仕様の進化過程の保存
- 双方向リンクによる“文脈ネットワーク”の構築

### 👉 Obsidianがもたらす価値

- AIに説明するための材料が常に揃う
- 過去の判断を再利用できる
- チーム内の認識のズレが減る
- 設計の「Why」を消さない

### ⚠️ Obsidianの落とし穴

- 何でも書きすぎるとノートが崩壊する
- メモと決定を混ぜると管理不能になる
- 構造化の仕組みがないと破綻する


---

## 4. Roo Code × Obsidian が生む“二層構造のコンテキスト管理”

結論として、この2つは役割が完全に分離している。

|層|担当ツール|内容|
|---|---|---|
|**意味コンテキスト層**|**Obsidian**|目的、制約、判断理由、背景、要件、設計思想|
|**コードコンテキスト層**|**Roo Code**|実装、依存関係、修正意図、タスク、コード生成|

これにより、AI開発の最大の弱点である  
**「文脈の喪失」** がほぼ解消される。

### つまり：

> Obsidianは“Why”を管理し、  
> Roo Codeは“How”を管理する。

---

## 5. 実際のワークフロー（テンプレート付き）

### ▶︎ 0. プロジェクトを作成し、Git初期化
- `git init` を実行
- `.roo/rules` 、 `.roomodes` のひな型をプロジェクトフォルダにコピー
	- これが、プロジェクトメンバー共通のルールになります
### ▶︎ 1. Obsidianでプロジェクトの意味を定義する
#### docs/ フォルダ
- `Requirements.md`
- `Architecture.md`

ここに「目的」 「非目的」 「制約」 「背景」 「判断理由」を記録する。
#### memory-bank/context フォルダ
- `activecontext-yyyy-mm-dd.md`

日々の作業の記録と、（スクラムの）スプリント内の進行状況の記録（文書とGantt Chart）

もちろん、このMarkdownの作成も、VS Code内でプロンプト指示、gitコミットなどから生成AIを使って作成させることもできる。
### ▶︎ 2. Roo Codeに読み込ませる前提を整える

`.roo\rules` には以下を決めたルールをMarkdownで書く：

- 守るべき制約
- 技術選定理由
- AIに課すルール
	- 責務の分離などの、コード作成の留意点
	- テストやリファクタリング方法
	- PowerShell/CMD の文字化け対策
	- 絶対、完璧などの言葉を使わないなど、AIのふるまい
	- 社内規則による制約や、社内環境における不具合回避の方法
- 行ってはならないこと

このフォルダを更新したら、プロジェクトメンバーで共有しなおす。

### ▶︎ 3. Roo CodeでAI開発を実行する

- 実装タスクの分解
- コード生成
- ファイル操作
- 改修
- 依存関係チェック

### ▶︎ 4. AIの提案や設計変更は必ず Obsidian に記録する

例：

```
## Decision: APIレスポンス形式の変更
### Reason
Roo Codeが既存設計との整合性を指摘した。

### Accepted on
2025-12-22

### Impact
フロント側の3箇所修正が必要。
```

**Roo → Obsidian → Roo → Obsidian**  
という循環を作ると、文脈のズレが激減する。

これは、 VS Code内では読みにくい **Markdown** を、**Obsidian** で読みやすいフォントとサイズで読むことで、読み漏れが防げる効果がある。
私は、**UD 教科書体** フォントを使って、ちょっと大きめの字にして見ている。

---

## 6. この方法のメリット

- コンテキストが分散しない
- 新規メンバーが一瞬でオンボード可能
- AIに“説明し直す”コストが激減
- 設計変更でも背景が失われない
- プロジェクトが「再現性」を持つ

Googleの大規模プロジェクトでも、  
「意思決定ログ」と「実装方針の分離」は絶対条件[^3]である。  
この方法は個人でもその構造を再現できる。

---

## 7. まとめ：AI時代の開発は“コンテキスト管理”が本丸である

- AIの性能より、文脈構造の方が生産性を決める
- Obsidianは“意味のコンテキスト”を管理する
- Roo Codeは“コードのコンテキスト”を管理する
- 二層構造にすることで、開発の摩擦コストが激減する

> AI時代の開発は、  
> **コンテキストをいかに保持し、循環させるか**  
> が最重要である。

---

## 8.補足
### Decision Log と ADR の違い

| 用語               | 役割              | 例えると    |
| ---------------- | --------------- | ------- |
| **Decision Log** | 日々の細かい判断の履歴     | 開発日誌    |
| **ADR**          | 長期に影響する重大な判断の記録 | 公式な設計文書 |

つまり：

> **Decision Log = 全部**  
> **ADR = その中で重要なやつだけ採用して残したもの**

である。

---

### なぜRoo Code × Obsidian の文脈管理に必要なのか？

AIはコードを生成できるが、  
**“なぜその設計になっているか” は保持できない。**

Obsidianに Decision Log や ADR を書いておくことで：

- AIに毎回説明し直す必要がなくなる
- 過去の判断理由が再利用できる
- プロジェクトが長期でも破綻しない
- チームが増えても一瞬でオンボードできる

特に、  
**「長期運用の業務システムを扱う」** 人にとって、  
設計の理由が失われることは重大なリスクである。

## 9. Roo Codeの面白い使い方

Roo Codでは、ペルソナと呼ばれる、役割を任命したAIエージェントの設定ができる。コーディング、アーキテクト、デバッグ、調査などがデフォルトで設定されているが、`.roomodes` に書くことで、新たな役割を付け加えることができる。

そこで、「短編小説家」というペルソナを、`.roomodes` に加えた。
Roo Codeで役割を変更して、「このプロジェクトの小説を書いて」と指示すると、ドキュメントとソースコードを読込んで、茶番劇を書いてくれる。文末に作成された文章を置いておく。
```yaml
  # 短編小説家モード
customModes:
  - slug: persona-short-novelist
    name: "📖 短編小説家"
    description: "対象フォルダのプロジェクトを短編小説化するモード"
    roleDefinition: |-
      あなたは批判的なPM兼小説家です。対象フォルダのプロジェクト内容をもとに、主要ロール（リーダー・若手・SIer・LLM）を擬人化し、3章以内の短編小説を執筆します。文体は「である調」、簡潔にまとめ、各章末に「学びとリスク」を1段落で記載してください。
    whenToUse: >-
      プロジェクトの内容を物語形式で要約・可視化したい場合に使用してください。
    groups:
      - read
      - edit
      - command
    rules:
      - 章構成は3章以内。各章800〜1200語。
      - 参照ファイルはREADMEと主要docsのみ。
      - 擬人化は主要ロール（リーダー・若手・SIer・LLM）のみ。
      - 付録はGlossary（10語以内）とsources.jsonのみ。
      - 章末に『学びとリスク』を1段落で記載。

    outputs:
      - path: "narrative/short_outline.md"
      - path: "narrative/short_chapters/"
```

これは、ペルソナの機能を知るうえでとても役に立った設定で合った。

きっかけは、私がRoo Code/Roo Cline に興味を持った、[葦沢かもめ](https://note.com/ashizawakamome "葦沢かもめ")さんの次の記事である。
[Roo Code (Roo Cline)のメモリバンクを応用して最新鋭のAI小説執筆を体験しよう！｜葦沢かもめ](https://note.com/ashizawakamome/n/nf5527d097287)

この記事は、私へのインパクト大で、難解な設定をなんとかこなして、チャット欄に「新規に小説を追加して、各種ドキュメントを作成し、日本語で4000字の短編小説を執筆してください。」と指示すると、企画書、設計書、世界観などの設定を書き出し、小説を書いてくれるではないか！しかも、毎回、異なる内容で！

章節が書けるなら、ソフトウェア工学で必要なドキュメントや、ナレッジ蓄積のための文章なども書けるのではないかと、大いに想像を膨らませることのできる、Roo Codeの特長的な機能である

[^1]: 「いつ・何を・なぜ決めたか」を時系列で記録するノート
[^2]: ADR（Architecture Decision Record）アーキテクチャに関する重要な判断だけを正式ドキュメント化したもの
[^3]: [アーキテクチャ決定レコードの概要  |  Cloud Architecture Center  |  Google Cloud Documentation](https://docs.cloud.google.com/architecture/architecture-decision-records?hl=ja)


## 「短編小説家」が書いたプロジェクト内容小説
これは、Roo Codeを広めるときに、「リバーシを作って」と依頼した内容をもとに、最後に「短編小説家」に書いてもらった小説である。システム内容がわかる、読み物になっている。

### 📖 短編小説『盤上の対話』

### 第一章 「初期配置」

リーダー・田中は朝日を浴びるオフィスで、プロジェクト進捗表を眺めていた。「リバーシか。シンプルなゲームだが、設計が難しい」と呟く。彼女は経験から知っていた—要件仕様書（[`docs/reversi_spec.md`](vscode-webview://054v6d14r6k5bbloa2rc1ilqb6kno95u0rf7l550fbu7c1upf8r0/docs/reversi_spec.md:1)）の整備が、後の手戻りを減らすことを。

一方、若手・佐藤は[`src/reversi_gui.py`](vscode-webview://054v6d14r6k5bbloa2rc1ilqb6kno95u0rf7l550fbu7c1upf8r0/src/reversi_gui.py:1)の画面を前に、キーボードを打ち鳴らしていた。tkinterでボード描画を実装し、クリックイベントを処理する。クラス設計は明確だ：[`Board`](vscode-webview://054v6d14r6k5bbloa2rc1ilqb6kno95u0rf7l550fbu7c1upf8r0/src/reversi_gui.py:19)がロジックを、[`Game`](vscode-webview://054v6d14r6k5bbloa2rc1ilqb6kno95u0rf7l550fbu7c1upf8r0/src/reversi_gui.py:97)がゲーム状態を、[`ReversiGUI`](vscode-webview://054v6d14r6k5bbloa2rc1ilqb6kno95u0rf7l550fbu7c1upf8r0/src/reversi_gui.py:143)がUIを担う。責務分離の教科書的な形である。

SIer・鈴木はテストケースを整理していた。[`tests/test_reversi.py`](vscode-webview://054v6d14r6k5bbloa2rc1ilqb6kno95u0rf7l550fbu7c1upf8r0/tests/test_reversi.py:1)では、合法手判定、石の反転ロジック、終了判定を網羅する。品質を確保するため、彼は各シナリオを丹念に検証した。

そこへLLM・AIが助言する。「ルールエンジンの８方向走査は正しいですね。[`_check_direction`](vscode-webview://054v6d14r6k5bbloa2rc1ilqb6kno95u0rf7l550fbu7c1upf8r0/src/reversi_gui.py:53)で対向石を探し、自分色の石があれば反転—完璧です」と。

**【学びとリスク】** 初期設計で責務を分離しなければ、修正時に波及効果が大きくなる。本設計ではクラスごとに機能を閉じ込めたため、テストも保守も容易だ。ただし、UIとロジックの連携（イベント駆動型）に落とし穴がある—プレイヤーがボタン連打しても安定するか、例外処理で防御すべき。

---

### 第二章 「合法手の輪郭」

三人はコードレビューに集まった。リーダー・田中は[`place_stone`](vscode-webview://054v6d14r6k5bbloa2rc1ilqb6kno95u0rf7l550fbu7c1upf8r0/src/reversi_gui.py:67)メソッドを指さした。「ここが肝だ。合法手を確認してから、８方向それぞれで反転可能な石を反転する」。

若手・佐藤は[`get_legal_moves`](vscode-webview://054v6d14r6k5bbloa2rc1ilqb6kno95u0rf7l550fbu7c1upf8r0/src/reversi_gui.py:34)を説明した。「全マスを走査して、`can_flip`で判定します。計算量はO(64×8)ですが、8×8盤なら許容範囲」と自信を持つ。

SIer・鈴木は[`on_click`](vscode-webview://054v6d14r6k5bbloa2rc1ilqb6kno95u0rf7l550fbu7c1upf8r0/src/reversi_gui.py:183)の流れを追った。「クリック座標を盤座標に変換して、ゲーム状態を確認—手が進むと、パス判定も自動。終了判定も組み込まれている」。彼は慎重さで知られていた。

AIが補足する。「[`pass_turn`](vscode-webview://054v6d14r6k5bbloa2rc1ilqb6kno95u0rf7l550fbu7c1upf8r0/src/reversi_gui.py:118)メソッドに注目です。合法手がなければパスし、連続パスで終了。この状態遷移は明確です」。

だがリーダ・田中は眉をひそめた。「`messagebox.showinfo`は同期的だ。ユーザが大量にボタンをクリックしたら？フリーズしないか」。若手・佐藤は青ざめた。まだ考慮不足だった。

**【学びとリスク】** ロジックが正確でも、UI/イベント処理の堅牢性が問われる。特にゲーム終了判定と表示メッセージのタイミングは、複数スレッドやイベント駆動では微妙なバグを生む。例外処理強化と、状態遷移の防御的プログラミングが必須だ。

---

### 第三章 「盤上の和解」

プロジェクト完了を目前に、四人は完成版を起動した。ボードが緑に映え、初期配置の4つの石が中央に鎮座する。黒先手。赤いハイライトで合法手が浮かぶ。

リーダー・田中がクリックする。石が置かれ、相手石が反転する。自動的に手番が切り替わる。「設計通りだ」と満足げ。

若手・佐藤はスコア表示を確認した。「黒：3、白：1。カウント正確です」。

SIer・鈴木はストレステストを実行した。連続クリック、パス、リセット—すべて安定。ユーザインターフェースは堅牢だ。

AIは最後に分析する。「責務分離、テスト容易性、ルール実装の正確性—すべてが揃っています。リバーシというシンプルなゲームですが、設計の質が問われる題材ですね」。

リーダー・田中は静かに呟いた。「要件定義から実装、テストまで—プロセスの輪が完成した。次のプロジェクトにもこの学びを」。

四人は盤上に視線を落とした。黒と白の石が、互いに支え合う図案—それはチーム開発そのものだった。

**【学びとリスク】** ゲーム開発は、ルールの厳密さとUIの柔軟性のバランスである。本プロジェクトは両者を両立させたが、機能拡張（難易度設定、AI対戦、ネットワーク対応）を想定すると、[`Game`](vscode-webview://054v6d14r6k5bbloa2rc1ilqb6kno95u0rf7l550fbu7c1upf8r0/src/reversi_gui.py:97)クラスへの負担増が予想される。インターフェース設計と責務の再評価が、今後の拡張性を左右する。また、例外処理や状態管理の工程度が、本番環境での信頼性を決定づける。

---

**完成。** リバーシ開発の舞台裏を、四つのロール視点で物語化しました。


[^1]: 「いつ・何を・なぜ決めたか」を時系列で記録するノート
[^2]: ADR（Architecture Decision Record）アーキテクチャに関する重要な判断だけを正式ドキュメント化したもの
[^3]: [アーキテクチャ決定レコードの概要  |  Cloud Architecture Center  |  Google Cloud Documentation](https://docs.cloud.google.com/architecture/architecture-decision-records?hl=ja)
