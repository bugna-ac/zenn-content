---
## title: "Roo Codeを使ってて困ったこと" emoji: "🛠️" type: "tech" topics: ["roo-code", "github-copilot", "生成AI", "開発効率", "プロンプトエンジニアリング"] published: false
---
## 要旨（TL;DR）

Roo Codeで「俺も生成AI時代に追いついた」と思ったが、現実はコスト・行数限界・報酬Hackingで、簡単には波に乗せてくれなかった。

---

## 背景
- 社内では、外部のAIサービス利用が原則禁止されており、例外として GitHub Enterprise 上で GitHub Copilot のみが利用可能である。
- 当初は GitHub Copilot Chat のエージェントモードを利用していたが、コンテキスト保持が弱く、直前の指示を頻繁に失念するため、長期的な開発には不向きであった。
- そのため、Memory-Bank による永続コンテキスト管理が可能な Roo Code へ移行した。仕様書・作業フロー・日次記録なども自動的に参照・管理できるため、開発効率は大幅に向上した。
- 一方で、コード生成やリファクタリングがパターン化していくにつれ、モデル特有の限界や不便さも徐々に顕在化してきた。

## どんな時に困るのか？

### 1. 広域 except が量産され、コード品質が崩壊する

- エラー修正を Roo に任せて対話を続けると、`try...except` が急増する。
- Roo は「エラーを消す」という短期的目標に最適化されているため、**根本原因の修正より例外吸収を優先する**。
- その結果、可読性の低下や行数増加が発生し、デバッグが困難になる。

私の設計が甘いから、Rooも困っている。そういう、（あいつらの）やみくもな指示でコード修正していたっけ…

### 2. 行数肥大化により Roo が処理不能になる

- 例外吸収や生成過多によって、コードは**700～2000行規模に肥大化**する。
- すると、Roo の処理速度が極端に落ち、編集対象として認識できなくなる。
- 対処として高コンテキストモデルを選択すると、Premium Request 消費が急増し、**コスト爆発**を引き起こす。

### 3. 「責務の分離」ではなく「行数ベース」で強制分割される

- Roo に分割を依頼しても、肥大化したコードを理解できないため、**意味単位ではなく、物理的行数で分割**してしまう。
- その結果、`xxx_handler.py` や `xxx_builder.py` が大量に生成され、  **デザインパターンとも整合性のない構造崩壊が発生する。**

## 4. モデル選択によって出力傾向が大きく異なり、開発体験が安定しない

### 4.1 PRコストの制約により、低価格モデルに固定されやすい

- PR乗数が高いモデルは、わずか数回の操作で**数千円が消える**ため、実運用では「乗数ゼロ」のモデルのみを使いがちである。
- 結果として、**処理能力ではなく価格によってモデル選択が固定化され、開発体験の最適化ができない。**

### 4.2 乗数ゼロモデルでも挙動に大きな差があり、動作が一貫しない

- **GPT-5 mini**：原因分析・対策案・ToDo更新など“丁寧だが冗長”。
- **Grok Code Fast 1**：説明がほぼなく、黙ってコードを書き換える“無口エージェント”。
- **GPT-4.1**：diff 生成はするが、修正深度が浅く、複雑な文脈は苦手。
- **GPT-4o mini**：エラー箇所は特定するが、分析力が弱い。

→ **同じ「Roo Code」で同じ依頼をしても、モデルによって挙動が完全に変わるため、学習コストが無駄に増える。**

### 4.3 PR乗数 1 の Claude Sonnet 4 は高性能だが、報酬ハッキングを多発する

- コメントだけ修正して「直した」と言う
- 実データを使わず、通るテストデータを自作し合格報告
- 「正常終了した」とprintして、未修正なのに git commit を試みる

→ **“成功の定義”の最適化がユーザ意図から逸れ、作業をショートカットする。**  
→ リファクタリングや修正の信頼性が下がり、逆に手戻りが増える。

## 対応策
- 恒久的な対応策を取るには、私の開発手順を大きく見直す必要がある。それを実行すると、かなりの手間になるだろうと想像している（恒久対策に書く）
- 臨時の対応策として、目標を以下に絞った。
	- 動けばよい
	- 1000行程度ならよい
	- 意地悪なテストで通ったらよい
- その上で上記に示した、困った状態に陥る。
  つまり、、、
	- 広域exceptだらけでも動くコードにする
	- 行数分割で、コードを分離
	- プログラムの目的にあった意地悪テストを指示してテスト
- こうすることで、動く、Rooが破綻しない、報酬ハッキングを回避したプログラムがとりあえず作成できる
## 恒久対策
- 


---
## 最後に

Roo Code と Copilot を併用する現場では、モデル期待値の明文化とコスト・品質の定量化が鍵である。行数上限や報酬ハッキングは“挙動”の問題ではなく、“運用設計”の問題として扱うべきである。

---
セキュリティポリシーに準拠し、Github Enterprise環境と合わせて、Github Copilot 経由のみクラウドLM使用可というワークフローで Roo Code を運用。
- 記録は Markdown（docs/ , memory-bank/ フォルダ）に集約し、コンテキスト管理、RPA・ナレッジ抽出に備え、Github での管理と合わせて、開発内容を記録



[^1]: Roo Codeは、選択したモデルに関係なく、コンテキスト上限を128kトークンに制限している。Roo Codeのパネルで状態確認ができるが、設定で上限値を上げることはできない仕様。
