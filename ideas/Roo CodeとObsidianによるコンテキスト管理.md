この記事は「Roo Code × Obsidian」という非常に新しい組み合わせであり、Zennでの差別化余地が大きい。  
以下では **Zenn記事としてそのまま執筆に使える構造（アウトライン＋本文のドラフト）** を提示する。  
である調で記す。

必要に応じて、このまま“全文生成”にも進める。

---

# 📝 Zenn記事アウトライン

# **Roo CodeとObsidianによるコンテキスト管理**

---

## 1. AI時代の開発で最大の課題は「コンテキストの損失」である

AIツール（ChatGPT, Claude, GitHub Copilot など）が普及したことで、  
コードを書く速度自体は劇的に速くなった。

しかし、開発全体の生産性はそこまで向上していない。  
理由は明確である。

### ❗人はプロンプトを忘れる。

### ❗AIは文脈を忘れる。

### ❗コードと仕様が“分断”される。

この「コンテキストの断絶」が、AI時代における最も大きな摩擦である。

本記事では、  
**Roo Code（AIを使ったコード文脈の保持）** と  
**Obsidian（意思決定・仕様・背景の保持）**  
を組み合わせた“コンテキスト管理”という新しい手法を紹介する。

---

## 2. Roo Codeが担うコンテキスト：

## **“コードベース”の理解と再現性**

Roo Code の強みは以下にある：

- `.roomodes` によるタスク別コンテキスト最適化
- `.roo\rules` によるプロジェクト全体ルール
- AIがプロジェクト全体を読み、局所ではなく“全体整合性”を考慮した提案を行う
- ファイル操作・差分生成など、開発作業をエージェント的に実行
- プロンプトがなくても「再現可能な開発プロセス」を維持できる

### 👉 Roo Codeが実現するもの

- 新規メンバーが入っても `.roomodes` と `.roo\rules` を読めば同じワークフローに乗れる
- “コードの背景文脈をAIが保持”する
- 個人依存ではなく“プロジェクト依存”の文脈になる

### ⚠️ Roo Codeの限界（盲点）

Roo Codeはコードの文脈には強いが、

- そもそもなぜその設計になったのか
- 業務要件・制約・背景
- 組織の判断理由（ADR）

といった **意味的コンテキスト** は保持しきれない。

これを放置すると、  
AIがコードを書いても“理由の欠落したプロダクト”になる。

そこで Obsidian が必要になる。

---

## 3. Obsidianが担うコンテキスト：

## **プロジェクトの「意味」「判断理由」「背景」**

Obsidianはコードエディタではない。  
しかし、**意思決定の文脈を保持するための最強のツール**である。

### Obsidianの役割

- 業務背景・要件・制約の整理
- 判断理由（Decision Log[^1] / ADR[^2]）の蓄積
- アイデア・仕様の進化過程の保存
- 双方向リンクによる“文脈ネットワーク”の構築

### 👉 Obsidianがもたらす価値

- AIに説明するための材料が常に揃う
- 過去の判断を再利用できる
- チーム内の認識のズレが減る
- 設計の「Why」を消さない

### ⚠️ Obsidianの落とし穴

- 何でも書きすぎるとノートが崩壊する
- メモと決定を混ぜると管理不能になる
- 構造化の仕組みがないと破綻する


---

## 4. Roo Code × Obsidian が生む“二層構造のコンテキスト管理”

結論として、この2つは役割が完全に分離している。

|層|担当ツール|内容|
|---|---|---|
|**意味コンテキスト層**|**Obsidian**|目的、制約、判断理由、背景、要件、設計思想|
|**コードコンテキスト層**|**Roo Code**|実装、依存関係、修正意図、タスク、コード生成|

これにより、AI開発の最大の弱点である  
**「文脈の喪失」** がほぼ解消される。

### つまり：

> Obsidianは“Why”を管理し、  
> Roo Codeは“How”を管理する。

---

## 5. 実際のワークフロー（テンプレート付き）

### ▶︎ 0. プロジェクトを作成し、Git初期化
- `git init` を実行
- `.roo/rules` 、 `.roomodes` のひな型をプロジェクトフォルダにコピー
	- これが、プロジェクトメンバー共通のルールになります
### ▶︎ 1. Obsidianでプロジェクトの意味を定義する
#### docs/ フォルダ
- `Requirements.md`
- `Architecture.md`

ここに「目的」 「非目的」 「制約」 「背景」 「判断理由」を記録する。
#### memory-bank/context フォルダ
- `activecontext-yyyy-mm-dd.md`

日々の作業の記録と、（スクラムの）スプリント内の進行状況の記録（文書とGantt Chart）

もちろん、このMarkdownの作成も、VS Code内でプロンプト指示、gitコミットなどから生成AIを使って作成させることもできる。
### ▶︎ 2. Roo Codeに読み込ませる前提を整える

`.roo\rules` には以下を決めたルールをMarkdownで書く：

- 守るべき制約
- 技術選定理由
- AIに課すルール
	- 責務の分離などの、コード作成の留意点
	- テストやリファクタリング方法
	- PowerShell/CMD の文字化け対策
	- 絶対、完璧などの言葉を使わないなど、AIのふるまい
	- 社内規則による制約や、社内環境における不具合回避の方法
- 行ってはならないこと

このフォルダを更新したら、プロジェクトメンバーで共有しなおす。

### ▶︎ 3. Roo CodeでAI開発を実行する

- 実装タスクの分解
- コード生成
- ファイル操作
- 改修
- 依存関係チェック

### ▶︎ 4. AIの提案や設計変更は必ず Obsidian に記録する

例：

```
## Decision: APIレスポンス形式の変更
### Reason
Roo Codeが既存設計との整合性を指摘した。

### Accepted on
2025-12-22

### Impact
フロント側の3箇所修正が必要。
```

**Roo → Obsidian → Roo → Obsidian**  
という循環を作ると、文脈のズレが激減する。

これは、 VS Code内では読みにくい **Markdown** を、**Obsidian** で読みやすいフォントとサイズで読むことで、読み漏れが防げる効果がある。
私は、**UD 教科書体** フォントを使って、ちょっと大きめの字にして見ている。

---

## 6. この方法のメリット

- コンテキストが分散しない
- 新規メンバーが一瞬でオンボード可能
- AIに“説明し直す”コストが激減
- 設計変更でも背景が失われない
- プロジェクトが「再現性」を持つ

Googleの大規模プロジェクトでも、  
「意思決定ログ」と「実装方針の分離」は絶対条件[^3]である。  
この方法は個人でもその構造を再現できる。

---

## 7. まとめ：AI時代の開発は“コンテキスト管理”が本丸である

- AIの性能より、文脈構造の方が生産性を決める
- Obsidianは“意味のコンテキスト”を管理する
- Roo Codeは“コードのコンテキスト”を管理する
- 二層構造にすることで、開発の摩擦コストが激減する

> AI時代の開発は、  
> **コンテキストをいかに保持し、循環させるか**  
> が最重要である。

---

## 8.補足
# Decision Log と ADR の違い

| 用語               | 役割              | 例えると    |
| ---------------- | --------------- | ------- |
| **Decision Log** | 日々の細かい判断の履歴     | 開発日誌    |
| **ADR**          | 長期に影響する重大な判断の記録 | 公式な設計文書 |

つまり：

> **Decision Log = 全部**  
> **ADR = その中で重要なやつだけ採用して残したもの**

である。

---

# 🧭 なぜRoo Code × Obsidian の文脈管理に必要なのか？

AIはコードを生成できるが、  
**“なぜその設計になっているか” は保持できない。**

Obsidianに Decision Log や ADR を書いておくことで：

- AIに毎回説明し直す必要がなくなる
- 過去の判断理由が再利用できる
- プロジェクトが長期でも破綻しない
- チームが増えても一瞬でオンボードできる

特に、  
**「長期運用の業務システムを扱う」** 人にとって、  
設計の理由が失われることは重大なリスクである。

[^1]: 「いつ・何を・なぜ決めたか」を時系列で記録するノート
[^2]: ADR（Architecture Decision Record）アーキテクチャに関する重要な判断だけを正式ドキュメント化したもの
[^3]: [アーキテクチャ決定レコードの概要  |  Cloud Architecture Center  |  Google Cloud Documentation](https://docs.cloud.google.com/architecture/architecture-decision-records?hl=ja)
